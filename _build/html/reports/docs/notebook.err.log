Traceback (most recent call last):
  File "C:\Users\Gebruiker\miniconda3\Lib\site-packages\jupyter_core\utils\__init__.py", line 154, in wrapped
    asyncio.get_running_loop()
    ~~~~~~~~~~~~~~~~~~~~~~~~^^
RuntimeError: no running event loop

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Users\Gebruiker\miniconda3\Lib\site-packages\jupyter_cache\executors\utils.py", line 58, in single_nb_execution
    executenb(
    ~~~~~~~~~^
        nb,
        ^^^
    ...<4 lines>...
        **kwargs,
        ^^^^^^^^^
    )
    ^
  File "C:\Users\Gebruiker\miniconda3\Lib\site-packages\nbclient\client.py", line 1319, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^
  File "C:\Users\Gebruiker\miniconda3\Lib\site-packages\jupyter_core\utils\__init__.py", line 158, in wrapped
    return loop.run_until_complete(inner)
           ~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^
  File "C:\Users\Gebruiker\miniconda3\Lib\asyncio\base_events.py", line 725, in run_until_complete
    return future.result()
           ~~~~~~~~~~~~~^^
  File "C:\Users\Gebruiker\miniconda3\Lib\site-packages\nbclient\client.py", line 709, in async_execute
    await self.async_execute_cell(
        cell, index, execution_count=self.code_cells_executed + 1
    )
  File "C:\Users\Gebruiker\miniconda3\Lib\site-packages\nbclient\client.py", line 1062, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "C:\Users\Gebruiker\miniconda3\Lib\site-packages\nbclient\client.py", line 918, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
import pandas as pd

# Stap 1: Laad de datasets
df1 = pd.read_csv("data.csv")           # Rajeevw (prestaties en fysieke data)
df2 = pd.read_csv("ufc-master.csv")     # Mdabbert (aanvullende info)

# Stap 2: Harmoniseer kolomnamen in df2
df2 = df2.rename(columns={
    'RedFighter': 'R_fighter',
    'BlueFighter': 'B_fighter'
})

# Stap 3: Merge datasets op vechtersnamen (datum wordt genegeerd)
df_merged = pd.merge(df1, df2, on=['R_fighter', 'B_fighter'], how='inner')

# Stap 4: Selecteer relevante kolommen
relevant_columns = [
    'R_age', 'B_age',
    'R_Height_cms', 'B_Height_cms',
    'R_Reach_cms', 'B_Reach_cms',
    'R_avg_SIG_STR_pct', 'B_avg_SIG_STR_pct',
    'R_avg_TD_pct', 'B_avg_TD_pct',
    'R_avg_SUB_ATT', 'B_avg_SUB_ATT',
    'weight_class',
    'Winner_x'
]
df_clean = df_merged[relevant_columns].copy()

# Stap 5: Verwijder onbekende waarden
df_clean = df_clean.replace(['Unknown', 'Unclear', 'unk', 'UNK', '?'], pd.NA)

# Stap 6: Verwijder rijen met ontbrekende waarden
df_clean = df_clean.dropna()

# Stap 7: Verwijder catchweight- Ã©n vrouwelijke gewichtsklassen
df_clean = df_clean[~df_clean['weight_class'].str.contains('Catch|Women', case=False, na=False)]

# Stap 8: Hernoem 'Winner_x' naar 'Winner'
df_clean = df_clean.rename(columns={'Winner_x': 'Winner'})

# Stap 9: Voeg verschilvariabelen toe
df_clean['age_diff'] = df_clean['R_age'] - df_clean['B_age']
df_clean['height_diff'] = df_clean['R_Height_cms'] - df_clean['B_Height_cms']
df_clean['reach_diff'] = df_clean['R_Reach_cms'] - df_clean['B_Reach_cms']
df_clean['strike_acc_diff'] = df_clean['R_avg_SIG_STR_pct'] - df_clean['B_avg_SIG_STR_pct']
df_clean['td_acc_diff'] = df_clean['R_avg_TD_pct'] - df_clean['B_avg_TD_pct']
df_clean['sub_att_diff'] = df_clean['R_avg_SUB_ATT'] - df_clean['B_avg_SUB_ATT']

# Stap 10: Opslaan als nieuwe CSV
df_clean.to_csv("ufc_clean.csv", index=False)

# Stap 11: Eerste 5 rijen laten zien
print(df_clean.head(5))
------------------


[31m---------------------------------------------------------------[39m
[31mAttributeError[39m                Traceback (most recent call last)
[36mCell[39m[36m [39m[32mIn[1][39m[32m, line 36[39m
[32m     33[39m df_clean = df_clean.dropna()
[32m     35[39m [38;5;66;03m# Stap 7: Verwijder catchweight- Ã©n vrouwelijke gewichtsklassen[39;00m
[32m---> [39m[32m36[39m df_clean = df_clean[~[43mdf_clean[49m[43m[[49m[33;43m'[39;49m[33;43mweight_class[39;49m[33;43m'[39;49m[43m][49m[43m.[49m[43mstr[49m.contains([33m'[39m[33mCatch|Women[39m[33m'[39m, case=[38;5;28;01mFalse[39;00m, na=[38;5;28;01mFalse[39;00m)]
[32m     38[39m [38;5;66;03m# Stap 8: Hernoem 'Winner_x' naar 'Winner'[39;00m
[32m     39[39m df_clean = df_clean.rename(columns={[33m'[39m[33mWinner_x[39m[33m'[39m: [33m'[39m[33mWinner[39m[33m'[39m})

[36mFile [39m[32m~\miniconda3\Lib\site-packages\pandas\core\generic.py:6318[39m, in [36mNDFrame.__getattr__[39m[34m(self, name)[39m
[32m   6311[39m [38;5;28;01mif[39;00m (
[32m   6312[39m     name [38;5;129;01mnot[39;00m [38;5;129;01min[39;00m [38;5;28mself[39m._internal_names_set
[32m   6313[39m     [38;5;129;01mand[39;00m name [38;5;129;01mnot[39;00m [38;5;129;01min[39;00m [38;5;28mself[39m._metadata
[32m   6314[39m     [38;5;129;01mand[39;00m name [38;5;129;01mnot[39;00m [38;5;129;01min[39;00m [38;5;28mself[39m._accessors
[32m   6315[39m     [38;5;129;01mand[39;00m [38;5;28mself[39m._info_axis._can_hold_identifiers_and_holds_name(name)
[32m   6316[39m ):
[32m   6317[39m     [38;5;28;01mreturn[39;00m [38;5;28mself[39m[name]
[32m-> [39m[32m6318[39m [38;5;28;01mreturn[39;00m [38;5;28;43mobject[39;49m[43m.[49m[34;43m__getattribute__[39;49m[43m([49m[38;5;28;43mself[39;49m[43m,[49m[43m [49m[43mname[49m[43m)[49m

[36mFile [39m[32m~\miniconda3\Lib\site-packages\pandas\core\accessor.py:224[39m, in [36mCachedAccessor.__get__[39m[34m(self, obj, cls)[39m
[32m    221[39m [38;5;28;01mif[39;00m obj [38;5;129;01mis[39;00m [38;5;28;01mNone[39;00m:
[32m    222[39m     [38;5;66;03m# we're accessing the attribute of the class, i.e., Dataset.geo[39;00m
[32m    223[39m     [38;5;28;01mreturn[39;00m [38;5;28mself[39m._accessor
[32m--> [39m[32m224[39m accessor_obj = [38;5;28;43mself[39;49m[43m.[49m[43m_accessor[49m[43m([49m[43mobj[49m[43m)[49m
[32m    225[39m [38;5;66;03m# Replace the property with the accessor object. Inspired by:[39;00m
[32m    226[39m [38;5;66;03m# https://www.pydanny.com/cached-property.html[39;00m
[32m    227[39m [38;5;66;03m# We need to use object.__setattr__ because we overwrite __setattr__ on[39;00m
[32m    228[39m [38;5;66;03m# NDFrame[39;00m
[32m    229[39m [38;5;28mobject[39m.[34m__setattr__[39m(obj, [38;5;28mself[39m._name, accessor_obj)

[36mFile [39m[32m~\miniconda3\Lib\site-packages\pandas\core\strings\accessor.py:194[39m, in [36mStringMethods.__init__[39m[34m(self, data)[39m
[32m    191[39m [38;5;28;01mdef[39;00m[38;5;250m [39m[34m__init__[39m([38;5;28mself[39m, data) -> [38;5;28;01mNone[39;00m:
[32m    192[39m     [38;5;28;01mfrom[39;00m[38;5;250m [39m[34;01mpandas[39;00m[34;01m.[39;00m[34;01mcore[39;00m[34;01m.[39;00m[34;01marrays[39;00m[34;01m.[39;00m[34;01mstring_[39;00m[38;5;250m [39m[38;5;28;01mimport[39;00m StringDtype
[32m--> [39m[32m194[39m     [38;5;28mself[39m._inferred_dtype = [38;5;28;43mself[39;49m[43m.[49m[43m_validate[49m[43m([49m[43mdata[49m[43m)[49m
[32m    195[39m     [38;5;28mself[39m._is_categorical = [38;5;28misinstance[39m(data.dtype, CategoricalDtype)
[32m    196[39m     [38;5;28mself[39m._is_string = [38;5;28misinstance[39m(data.dtype, StringDtype)

[36mFile [39m[32m~\miniconda3\Lib\site-packages\pandas\core\strings\accessor.py:248[39m, in [36mStringMethods._validate[39m[34m(data)[39m
[32m    245[39m inferred_dtype = lib.infer_dtype(values, skipna=[38;5;28;01mTrue[39;00m)
[32m    247[39m [38;5;28;01mif[39;00m inferred_dtype [38;5;129;01mnot[39;00m [38;5;129;01min[39;00m allowed_types:
[32m--> [39m[32m248[39m     [38;5;28;01mraise[39;00m [38;5;167;01mAttributeError[39;00m([33m"[39m[33mCan only use .str accessor with string values![39m[33m"[39m)
[32m    249[39m [38;5;28;01mreturn[39;00m inferred_dtype

[31mAttributeError[39m: Can only use .str accessor with string values!

